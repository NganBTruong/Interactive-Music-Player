<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Hub - Playback/Sort Fix!</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://w.soundcloud.com/player/api.js"></script> <style>
        /* --- CSS (No changes) --- */
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f0f2f5; display: flex; min-height: 100vh; overflow: hidden; }
        .main-container { display: flex; width: 100%; height: 100vh; overflow: hidden; }
        #left-column { min-width: 320px; padding: 0; background-color: #f9f9f9; overflow: hidden; box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1); display: flex; flex-direction: column; box-sizing: border-box; }
        .resizer { width: 10px; background-color: #c1c1c1; cursor: ew-resize; flex-shrink: 0; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .resizer::after { content: '⋮'; font-size: 18px; color: #555; line-height: 0; }
        #right-column { flex-grow: 1; min-width: 350px; padding: 20px; background-color: #ffffff; overflow-y: auto; display: flex; flex-direction: column; box-sizing: border-box; }
        body.is-resizing iframe, body.is-resizing .widget-content-area { pointer-events: none; } body.is-resizing { cursor: ew-resize; }
        button, .button-like { padding: 8px 15px; font-size: 14px; border-radius: 5px; cursor: pointer; border: 1px solid transparent; transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; text-align: center; font-weight: bold; line-height: 1.4; }
        button:hover, .button-like:hover { box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .control-btn { background: #e0e0e0; color: #333; border-color: #ccc; width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; margin: 0 5px; padding: 0; } .control-btn:hover { background: #d0d0d0; }
        .btn-primary { background-color: #007bff; color: white; border-color: #007bff;} .btn-primary:hover { background-color: #0056b3; border-color: #0056b3;}
        .btn-danger { background-color: #d9534f; color: white; border-color: #d9534f;} .btn-danger:hover { background-color: #c9302c; border-color: #c9302c;}
        .btn-success { background-color: #28a745; color: white; border-color: #28a745;} .btn-success:hover { background-color: #218838; border-color: #218838;}
        .btn-secondary { background-color: #6c757d; color: white; border-color: #6c757d;} .btn-secondary:hover { background-color: #5a6268; border-color: #545b62;}
        .delete-item-btn { color: #d9534f; background: none; border: none; padding: 5px; line-height: 1; flex-shrink: 0; font-weight: normal; margin-left: auto; } .delete-item-btn:hover { color: #c9302c; background: #f0f0f0;}
        .music-player-container { flex-grow: 1; display: flex; flex-direction: column; margin: 0; background-color: #ffffff; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); padding: 0; width: 100%; box-sizing: border-box; overflow: hidden; }
        .player-tabs { display: flex; border-bottom: 1px solid #ddd; flex-shrink: 0; }
        .player-tab-btn { padding: 10px 15px; cursor: pointer; border: none; background-color: #f0f0f0; color: #555; font-size: 14px; flex-grow: 1; text-align: center; border-bottom: 3px solid transparent; }
        .player-tab-btn.active { background-color: #fff; font-weight: bold; color: #333; border-bottom-color: #007bff;}
        .player-tab-content { padding: 20px; overflow-y: auto; flex-grow: 1; display: none; flex-direction: column; }
        .player-tab-content.active { display: flex; }
        .video-container { position: relative; width: 100%; padding-bottom: 56.25%; height: 0; border-radius: 10px; overflow: hidden; background-color: #ddd; margin-bottom: 15px; background-size: cover; background-position: center; flex-shrink: 0; }
        .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0; }
        .song-title { margin: 10px 0; font-size: 18px; font-weight: bold; color: #333; text-align: center; flex-shrink: 0; }
        .player-controls-area { flex-shrink: 0; }
        .controls { display: flex; justify-content: center; align-items: center; margin-top: 10px; flex-wrap: wrap; gap: 5px;}
        .progress-container { display: flex; align-items: center; justify-content: center; margin-top: 15px; }
        .progress-bar { width: 70%; height: 15px; background-color: #ddd; border-radius: 10px; position: relative; overflow: hidden; cursor: pointer; flex-grow: 1; }
        .progress { height: 100%; background-color: #888; width: 0%; transition: width 0.3s ease; border-radius: 10px; }
        .time { font-size: 14px; margin: 0 10px; color: #555; flex-shrink: 0; }
        .playlist-container { margin-top: 20px; overflow-y: auto; border: 1px solid #ddd; border-radius: 10px; background: #f9f9f9; padding: 10px; flex-grow: 1; min-height: 100px; }
        .playlist-item { display: flex; align-items: center; padding: 10px; margin-bottom: 5px; cursor: pointer; background-color: #fff; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: background-color 0.3s; }
        .playlist-item:hover { background-color: #f0f0f0; }
        .playlist-item.active-track { background-color: #d1e7ff; border-left: 4px solid #007bff; }
        .playlist-item img { width: 40px; height: 40px; background-color: #ddd; display: flex; justify-content: center; align-items: center; color: #555; border-radius: 5px; margin-right: 10px; flex-shrink: 0;}
        .playlist-item div { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        .volume-container { display: flex; align-items: center; margin-left: 15px; }
        .volume-slider-container { width: 80px; height: 15px; background-color: #ddd; border-radius: 5px; position: relative; cursor: pointer; }
        .volume-thumb { position: absolute; top: 50%; transform: translateY(-50%); width: 12px; height: 12px; background-color: #888; border-radius: 50%; left: 50%; }
        .media-input-area { margin-top: 10px; padding-top: 0; border-top: none; margin-bottom: 15px; flex-shrink: 0;}
        .media-input-area h4 { margin-top:0; margin-bottom: 10px; font-size: 1.1em; color: #333;}
        .media-input-area p { font-size: 0.9em; color: #666; margin-bottom: 15px;}
        .media-input-container { display: flex; margin-bottom: 5px; }
        #media-url-input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px 0 0 5px; font-size: 14px; min-width: 100px; }
        #load-media-btn { border-radius: 0 5px 5px 0; flex-shrink: 0; }
        .load-instructions { font-size: 0.8em; color: #888; margin-top: 5px;}
        #playlist-editor-list { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; background: #f9f9f9;}
        #playlist-editor-list li { padding: 10px; background-color: #fff; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 10px; cursor: grab; }
        #playlist-editor-list li:last-child { border-bottom: none; }
        #playlist-editor-list img { width: 30px; height: 30px; border-radius: 3px; flex-shrink: 0; }
        #playlist-editor-list div { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.95em; }
        .sortable-ghost { background-color: #cce5ff; opacity: 0.7; } .sortable-drag { background-color: #e9f5ff; }
        .widget-tabs { display: flex; margin-bottom: 0; border-bottom: 1px solid #ddd; flex-wrap: wrap; }
        .widget-tab-btn { background-color: #f0f0f0; color:#333; border-color:transparent; border-bottom: none; border-radius: 5px 5px 0 0; margin-right: 5px; position: relative; bottom: -1px; padding: 10px 15px; margin-bottom: -1px; } .widget-tab-btn:hover { background-color: #e7e7e7; } .widget-tab-btn.active { background-color: #fff; border-color: #ddd #ddd transparent #ddd; font-weight: bold; border-bottom: 1px solid #fff; z-index: 1; }
        .widget-content-area { border: 1px solid #ddd; border-top: none; padding: 15px; flex-grow: 1; display: flex; flex-direction: column; }
        .widget-card { background-color: #fff; box-sizing: border-box; display: none; flex-direction: column; height: 100%; } .widget-card.active-widget { display: flex; }
        .checklist-widget {} .checklist-input-container { display: flex; margin-bottom: 15px; } #checklist-item-input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px 0 0 5px; font-size: 15px; } #add-checklist-item-btn { border-radius: 0 5px 5px 0; } #checklist { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; min-height: 100px; } #checklist li { display: flex; align-items: center; padding: 10px 0; border-bottom: 1px solid #eee; font-size: 16px; } #checklist li:last-child { border-bottom: none; } #checklist input[type="checkbox"] { appearance: none; -webkit-appearance: none; -moz-appearance: none; width: 20px; height: 20px; border: 2px solid #888; border-radius: 50%; margin-right: 12px; cursor: pointer; position: relative; outline: none; flex-shrink: 0; } #checklist input[type="checkbox"]:checked { background-color: #007bff; border-color: #007bff; } #checklist input[type="checkbox"]:checked::before { content: ''; position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; background-color: white; border-radius: 50%; transform: translate(-50%, -50%); } #checklist label { flex-grow: 1; cursor: pointer; color: #333; word-break: break-word; } #checklist input[type="checkbox"]:checked + label { text-decoration: line-through; color: #aaa; }
        .notes-widget { flex-grow: 1; display: flex; flex-direction: column; } #notes-area { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 15px; resize: vertical; box-sizing: border-box; min-height: 200px; flex-shrink: 0; } .sticky-notes-section { margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; flex-grow: 1; display: flex; flex-direction: column; } .sticky-notes-section h4 { margin-top: 0; margin-bottom: 10px;} #sticky-notes-controls { margin-bottom: 10px; } #sticky-notes-board { flex-grow: 1; border: 1px dashed #ccc; border-radius: 5px; position: relative; overflow: auto; background-color: #fdfdfd; min-height: 250px; } .sticky-note { position: absolute; width: 180px; height: 180px; background-color: #ffc; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); padding: 0; box-sizing: border-box; cursor: move; display: flex; flex-direction: column; border: 1px solid #e6e6a1; overflow: hidden; } .sticky-note-header { display: flex; justify-content: flex-end; height: 20px; padding: 2px 5px; background-color: rgba(0,0,0,0.05); flex-shrink: 0;} .delete-sticky-btn { font-size: 14px; width: 18px; height: 18px; line-height: 16px; padding: 0; background: rgba(0,0,0,0.1); color: #333; border: none; border-radius: 50%; cursor: pointer; opacity: 0.5; } .sticky-note:hover .delete-sticky-btn { opacity: 1; } .sticky-note textarea { flex-grow: 1; border: none; background-color: transparent; resize: none; outline: none; font-family: 'Architects Daughter', cursive; font-size: 1em; padding: 8px; box-sizing: border-box; }
        .flashcards-widget { display: flex; flex-direction: column; gap: 15px; flex-grow:1; } .flashcard-display-area { min-height: 180px; border: 1px solid #ccc; border-radius: 8px; display: flex; align-items: center; justify-content: center; text-align: center; padding: 20px; font-size: 1.4em; cursor: pointer; background-color: #f9f9f9; position: relative; perspective: 1000px; overflow: hidden; } .flashcard-face { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; backface-visibility: hidden; transition: transform 0.7s ease-in-out; position: absolute; overflow-wrap: break-word; word-wrap: break-word; padding: 10px; box-sizing: border-box; } .flashcard-front { transform: rotateY(0deg); } .flashcard-back { transform: rotateY(180deg); background-color: #e8f4fd; border-radius: 8px;} .flashcard-display-area.is-flipped .flashcard-front { transform: rotateY(180deg); } .flashcard-display-area.is-flipped .flashcard-back { transform: rotateY(0deg); } .flashcard-nav { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 5px;} #current-card-info { font-size: 0.9em; color: #666; margin: 0 10px; } #flip-flashcard-btn { width:100%; margin-top:5px; } .add-flashcard-area { margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;} .add-flashcard-area div { margin-bottom: 10px; } .add-flashcard-area label { display: block; margin-bottom: 5px; font-weight: bold;} .add-flashcard-area input[type="text"], .add-flashcard-area textarea { width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em; } .add-flashcard-area textarea { min-height: 60px; resize: vertical; } .flashcard-term-list-container { margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee; flex-grow: 1; display: flex; flex-direction: column; min-height: 100px; } .flashcard-term-list-container h4 { margin-top:0; margin-bottom: 10px; } #flashcard-term-list { list-style-type: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; border: 1px solid #eee; border-radius: 4px; } #flashcard-term-list li { padding: 8px 10px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: baseline; gap: 15px; } #flashcard-term-list li:last-child { border-bottom: none; } #flashcard-term-list li:hover { background-color: #e9ecef; } #flashcard-term-list li span.term { font-weight: bold; flex-shrink: 0; margin-right: 10px;} #flashcard-term-list li span.definition { font-size: 0.9em; color: #555; text-align: right; flex-grow: 1; word-break: break-word; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&display=swap" rel="stylesheet">
</head>
<body>
    <div class="main-container">
        <section id="left-column"> <div class="music-player-container"> <div class="player-tabs"> <button class="player-tab-btn active" data-player-tab="player">Player</button> <button class="player-tab-btn" data-player-tab="load-link">Add & Organize</button> </div> <div class="player-tab-content active" id="player-content-area"> <div class="video-container" id="main-video-player"></div> <div class="song-title">Select a Song or Video</div> <div class="player-controls-area"> <div class="controls"> <button id="prev-btn" class="control-btn">⏮</button> <button id="play-btn" class="control-btn">▶</button> <button id="pause-btn" class="control-btn" style="display: none;">⏸</button> <button id="next-btn" class="control-btn">⏭</button> <div class="volume-container"> <div class="volume-slider-container" id="volume-slider"><div class="volume-thumb"></div></div> </div> </div> <div class="progress-container"> <div class="time" id="current-time">0:00</div> <div class="progress-bar" id="progress-bar"><div class="progress" id="progress"></div></div> <div class="time" id="duration">0:00</div> </div> </div> <div class="playlist-container" id="playlist-container-display"> </div> </div> <div class="player-tab-content" id="link-loader-area"> <div class="media-input-area"> <h4>Add Media to Playlist:</h4> <p>Paste YouTube URL or full SoundCloud Embed Code.</p> <div class="media-input-container"> <input type="text" id="media-url-input" placeholder="YouTube URL or full <iframe...> code"> <button id="load-media-btn" class="btn-success">Add Media</button> </div> <div class="load-instructions">For SoundCloud: Click Share > Embed > Copy the full iframe code.</div> </div> <h4>Edit Playlist Order (Drag & Drop):</h4> <ul id="playlist-editor-list"> </ul> </div> </div> </section>
        <div class="resizer" id="drag-handle"></div>
        <section id="right-column"> <div class="widget-tabs"> <button class="widget-tab-btn active" data-widget="checklist">Checklist</button> <button class="widget-tab-btn" data-widget="notes">Notes & Sticky</button> <button class="widget-tab-btn" data-widget="flashcards">Flashcards</button> </div> <div class="widget-content-area"> <div class="checklist-widget widget-card active-widget" id="checklist-widget"> <div class="checklist-input-container"> <input type="text" id="checklist-item-input" placeholder="Add a new task..."> <button id="add-checklist-item-btn" class="btn-primary">Add</button> </div> <ul id="checklist"></ul> </div> <div class="notes-widget widget-card" id="notes-widget" style="display: none;"> <textarea id="notes-area" placeholder="Write your main notes here..."></textarea> <div class="sticky-notes-section"> <h4>Sticky Notes</h4> <div id="sticky-notes-controls"> <button id="add-sticky-note-btn" class="btn-primary">Add New Sticky Note</button> </div> <div id="sticky-notes-board"></div> </div> </div> <div class="flashcards-widget widget-card" id="flashcards-widget" style="display: none;"> <h3>Flashcards</h3> <div class="flashcard-display-area" id="flashcard-display" tabindex="0"> <div class="flashcard-face flashcard-front" id="flashcard-front">Term</div> <div class="flashcard-face flashcard-back" id="flashcard-back">Definition</div> </div> <div class="flashcard-nav"> <button id="prev-flashcard-btn" class="btn-secondary">⬅️ Previous</button> <span id="current-card-info">0/0</span> <button id="next-flashcard-btn" class="btn-secondary">Next ➡️</button> </div> <div class="flashcard-nav"> <button id="flip-flashcard-btn" class="btn-secondary" style="width:100%; margin-top:5px;">Show Answer / Flip</button> </div> <div class="add-flashcard-area"> <h4>Add New Flashcard</h4> <div><label for="flashcard-term-input">Term (Front):</label><input type="text" id="flashcard-term-input"></div> <div><label for="flashcard-definition-input">Definition (Back):</label><textarea id="flashcard-definition-input"></textarea></div> <button id="add-new-flashcard-btn" class="btn-success">Add Card</button> </div> <div class="flashcard-term-list-container"> <h4>Your Flashcard Terms:</h4> <ul id="flashcard-term-list"></ul> </div> </div> </div> </section>
    </div>

    <script>
        // --- Constants & State ---
        const leftColumn = document.getElementById('left-column'); const rightColumn = document.getElementById('right-column'); const dragHandle = document.getElementById('drag-handle'); const playerTabs = document.querySelectorAll('.player-tab-btn'); const playerTabContents = document.querySelectorAll('.player-tab-content'); const playBtn = document.getElementById('play-btn'); const pauseBtn = document.getElementById('pause-btn'); const prevBtn = document.getElementById('prev-btn'); const nextBtn = document.getElementById('next-btn'); const progressBarElem = document.getElementById('progress'); const progressBarContainer = document.getElementById('progress-bar'); const currentTimeElem = document.getElementById('current-time'); const durationElem = document.getElementById('duration'); const playlistContainerDisplay = document.getElementById('playlist-container-display'); const playlistEditorList = document.getElementById('playlist-editor-list'); const volumeSlider = document.getElementById('volume-slider'); const volumeThumb = volumeSlider ? volumeSlider.querySelector('.volume-thumb') : null; const songTitleElem = document.getElementById('song-title'); const mainVideoPlayerContainer = document.getElementById('main-video-player'); const playerControlsArea = document.querySelector('.player-controls-area'); const mediaUrlInput = document.getElementById('media-url-input'); const loadMediaBtn = document.getElementById('load-media-btn'); const widgetTabs = document.querySelectorAll('.widget-tab-btn'); const widgetContents = document.querySelectorAll('.widget-content-area .widget-card'); const checklistItemInput = document.getElementById('checklist-item-input'); const addChecklistItemBtn = document.getElementById('add-checklist-item-btn'); const checklist = document.getElementById('checklist'); const flashcardDisplay = document.getElementById('flashcard-display'); const flashcardFront = document.getElementById('flashcard-front'); const flashcardBack = document.getElementById('flashcard-back'); const prevFlashcardBtn = document.getElementById('prev-flashcard-btn'); const nextFlashcardBtn = document.getElementById('next-flashcard-btn'); const flipFlashcardBtn = document.getElementById('flip-flashcard-btn'); const currentCardInfo = document.getElementById('current-card-info'); const flashcardTermInput = document.getElementById('flashcard-term-input'); const flashcardDefinitionInput = document.getElementById('flashcard-definition-input'); const addNewFlashcardBtn = document.getElementById('add-new-flashcard-btn'); const flashcardTermListUL = document.getElementById('flashcard-term-list'); const addStickyNoteBtn = document.getElementById('add-sticky-note-btn'); const stickyNotesBoard = document.getElementById('sticky-notes-board');
        const notesArea = document.getElementById('notes-area');

        // State variables
        let isResizing = false; let initialPosX = 0; let initialLeftWidth = 0; let calculatedLeftMinWidth = 320;
        let audio = new Audio(); let currentTrackIndex = -1; let currentMediaType = null; let activeMediaFrame = null;
        let tracks = []; // Single source of truth
        let isDraggingProgress = false; let isDraggingVolume = false;
        let sortableInstance = null; let checklistItemIdCounter = 0;
        let flashcards = []; let currentFlashcardIndex = -1; let isFlashcardFlipped = false;
        let stickyNoteZIndex = 1;

        let youtubePlayer = null; // For YouTube API if you decide to add deeper integration
        let soundcloudWidget = null; // For SoundCloud Widget API

        const defaultThumbnail = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 10 10"><rect width="10" height="10" fill="%23eeeeee"/></svg>';

        // --- COLUMN RESIZER ---
        function calculateLeftMinWidth() { const mediaInputArea = document.querySelector('.media-input-area'); const controlsArea = document.querySelector('.controls'); let requiredWidth = 0; if(mediaInputArea && mediaInputArea.offsetParent !== null) { requiredWidth = mediaInputArea.scrollWidth + 40; } if(controlsArea && controlsArea.offsetParent !== null) { let controlsWidth = Array.from(controlsArea.children).reduce((sum, el) => sum + el.offsetWidth + 10, 0) + 20; requiredWidth = Math.max(requiredWidth, controlsWidth); } const cssMin = parseFloat(getComputedStyle(leftColumn).minWidth) || 320; calculatedLeftMinWidth = Math.max(cssMin, requiredWidth, 320); }
        function handleResizerMouseMove(e) { if (!isResizing) return; const deltaX = e.clientX - initialPosX; let newLeftWidth = initialLeftWidth + deltaX; const rightMinWidth = parseFloat(getComputedStyle(rightColumn).minWidth) || 350; const containerWidth = leftColumn.parentElement.offsetWidth; const resizerWidth = dragHandle.offsetWidth || 10; newLeftWidth = Math.max(calculatedLeftMinWidth, Math.min(newLeftWidth, containerWidth - rightMinWidth - resizerWidth)); leftColumn.style.flexBasis = `${newLeftWidth}px`; }
        function handleResizerMouseUp() { if (!isResizing) return; isResizing = false; document.body.classList.remove('is-resizing'); document.removeEventListener('mousemove', handleResizerMouseMove); document.removeEventListener('mouseup', handleResizerMouseUp); saveState(); /* Save width change */ }
        if (dragHandle) { dragHandle.addEventListener('mousedown', function(e) { e.preventDefault(); isResizing = true; initialPosX = e.clientX; initialLeftWidth = leftColumn.offsetWidth; calculateLeftMinWidth(); document.body.classList.add('is-resizing'); document.addEventListener('mousemove', handleResizerMouseMove); document.addEventListener('mouseup', handleResizerMouseUp); }); }


        // --- LEFT PLAYER TABS ---
        playerTabs.forEach(tab => { tab.addEventListener('click', () => { playerTabs.forEach(t => t.classList.remove('active')); playerTabContents.forEach(c => c.classList.remove('active')); tab.classList.add('active'); const targetTabName = tab.dataset.playerTab; let targetContentId = ''; if (targetTabName === 'player') targetContentId = 'player-content-area'; else if (targetTabName === 'load-link') targetContentId = 'link-loader-area'; const targetContent = document.getElementById(targetContentId); if (targetContent) { targetContent.classList.add('active'); } else { console.error("Target content area not found for player tab:", targetTabName); } }); });

        // --- MEDIA PLAYER & PLAYLIST ---
        function renderPlaylistView(container, isEditable) {
             if (!container) { console.error("Playlist container not found:", container); return; }
             const fragment = document.createDocumentFragment();
             if (tracks.length === 0) { const emptyMsg = document.createElement(isEditable ? 'li' : 'div'); emptyMsg.textContent = isEditable ? 'Playlist empty.' : 'Playlist empty. Add in "Add & Organize" tab.'; emptyMsg.style.padding = '10px'; emptyMsg.style.color = '#777'; fragment.appendChild(emptyMsg); }
             else {
                 tracks.forEach((track, index) => {
                     const item = document.createElement(isEditable ? 'li' : 'div');
                     item.classList.add('playlist-item');
                     item.dataset.index = index;
                     item.dataset.trackSrc = track.src;
                     const img = document.createElement('img');
                     img.src = track.thumbnail || defaultThumbnail;
                     img.alt = track.title ? track.title.substring(0, 10) : 'Track';
                     img.onerror = function() { this.onerror=null; this.src = defaultThumbnail; };
                     item.appendChild(img);
                     const titleDiv = document.createElement('div');
                     titleDiv.textContent = track.title || "Unknown Title";
                     item.appendChild(titleDiv);
                     if (isEditable) {
                         item.dataset.trackId = index; // Keep if used by Sortable or other logic
                         const deleteBtn = document.createElement('button');
                         deleteBtn.innerHTML = '🗑️'; deleteBtn.className = 'delete-item-btn'; deleteBtn.title = 'Remove from Playlist'; deleteBtn.type = "button";
                         deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); if (confirm(`Remove "${track.title}" from playlist?`)) { deleteTrack(index); } });
                         item.appendChild(deleteBtn);
                     } else {
                         if (index === currentTrackIndex) { item.classList.add('active-track'); }
                     }
                     fragment.appendChild(item);
                 });
             }
             container.innerHTML = '';
             container.appendChild(fragment);
        }
        if (playlistContainerDisplay) {
             playlistContainerDisplay.addEventListener('click', (event) => {
                 const clickedItem = event.target.closest('.playlist-item');
                 if (clickedItem && playlistContainerDisplay.contains(clickedItem)) {
                     const index = parseInt(clickedItem.dataset.index);
                     if (!isNaN(index) && index >= 0 && index < tracks.length) {
                         currentTrackIndex = index;
                         loadTrackFromPlaylist(currentTrackIndex);
                     } else { console.error("Could not get valid index from clicked playlist item:", clickedItem.dataset.index); }
                 }
             });
        } else { console.error("Display playlist container not found for event delegation."); }

        function renderAllPlaylists() { renderPlaylistView(playlistContainerDisplay, false); renderPlaylistView(playlistEditorList, true); }

        function deleteTrack(index) {
            if (index >= 0 && index < tracks.length) {
                tracks.splice(index, 1);
                if (currentTrackIndex === index) {
                    currentTrackIndex = -1; // Will be handled by load logic
                    clearPlayerScreen();
                    if (songTitleElem) songTitleElem.textContent = "Select a Song or Video";
                    if (tracks.length > 0) {
                        currentTrackIndex = Math.max(0, index -1); // Try to select previous or first
                        loadTrackFromPlaylist(currentTrackIndex);
                    } else {
                        updateProgressBar(); // Reset progress if playlist empty
                    }
                } else if (currentTrackIndex > index) {
                    currentTrackIndex--;
                }
                renderAllPlaylists();
                updateProgressBar(); // Update in case current track changed or UI needs reset
                saveState();
            }
        }

        function initializePlaylist() {
             renderAllPlaylists();
             if (tracks.length > 0) {
                if (currentTrackIndex === -1 || currentTrackIndex >= tracks.length) {
                    currentTrackIndex = 0;
                }
                loadTrackFromPlaylist(currentTrackIndex);
             }
             else {
                if(songTitleElem) songTitleElem.textContent = "Playlist Empty";
                updateProgressBar(); // Ensure progress bar is cleared if no tracks
             }
        }

        function initializePlaylistEditorSortable() {
            if (playlistEditorList && !sortableInstance) {
                try {
                    sortableInstance = new Sortable(playlistEditorList, {
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        dragClass: 'sortable-drag',
                        onEnd: function (evt) {
                            if (evt.oldIndex !== evt.newIndex) {
                                const movedItem = tracks.splice(evt.oldIndex, 1)[0];
                                tracks.splice(evt.newIndex, 0, movedItem);
                                if (currentTrackIndex === evt.oldIndex) {
                                    currentTrackIndex = evt.newIndex;
                                } else if (evt.oldIndex < currentTrackIndex && evt.newIndex >= currentTrackIndex) {
                                    currentTrackIndex--;
                                } else if (evt.oldIndex > currentTrackIndex && evt.newIndex <= currentTrackIndex) {
                                    currentTrackIndex++;
                                }
                                renderPlaylistView(playlistContainerDisplay, false); // Re-render non-editable list
                                // The editable list re-orders visually by Sortable, data is now synced
                                saveState();
                            }
                        },
                    });
                } catch (error) { console.error("Failed to initialize SortableJS:", error); }
            } else if (!playlistEditorList) { console.error("Playlist editor list element not found for SortableJS init."); }
        }

        function clearPlayerScreen() {
            if (soundcloudWidget) {
                // Unbind specific events if necessary, or rely on removing iframe.
                // soundcloudWidget.unbind(SC.Widget.Events.PLAY);
                // ...
                soundcloudWidget = null;
            }
            if (youtubePlayer) {
                // youtubePlayer.destroy(); // If using YT API
                youtubePlayer = null;
            }
            mainVideoPlayerContainer.innerHTML = '';
            mainVideoPlayerContainer.style.backgroundImage = 'none';
            mainVideoPlayerContainer.style.paddingBottom = "56.25%";
            activeMediaFrame = null;
            mainVideoPlayerContainer.style.height = "0";
        }

        function getYouTubeVideoID(url) { const regExp = /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/; const match = url.match(regExp); return (match && match[2] && match[2].length === 11) ? match[2] : null; }
        function getSoundCloudEmbedSrc(iframeCode) { if (typeof iframeCode === 'string' && iframeCode.trim().startsWith('<iframe')) { const match = iframeCode.match(/src="([^"]*)"/); if (match && match[1] && match[1].includes('w.soundcloud.com/player')) return match[1]; } return null; }

        function loadMediaToPlayer(urlOrId, type, title = "Loading...") {
            clearPlayerScreen();
            audio.pause();
            if (songTitleElem) songTitleElem.textContent = title;
            currentMediaType = type;

            if (type === 'youtube') {
                const videoID = getYouTubeVideoID(urlOrId);
                if (videoID) {
                    activeMediaFrame = document.createElement('iframe');
                    activeMediaFrame.src = `https://www.youtube.com/embed/${videoID}?autoplay=1&modestbranding=1&rel=0&enablejsapi=1&origin=${window.location.origin}`;
                    activeMediaFrame.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
                    activeMediaFrame.allowFullscreen = true;
                    if (mainVideoPlayerContainer) mainVideoPlayerContainer.appendChild(activeMediaFrame);
                    if (playerControlsArea) playerControlsArea.style.display = 'none';
                } else {
                    if (songTitleElem) songTitleElem.textContent = "Invalid YouTube URL";
                }
            } else if (type === 'soundcloud') {
                if (urlOrId.includes('w.soundcloud.com/player')) {
                    activeMediaFrame = document.createElement('iframe');
                    activeMediaFrame.id = 'soundcloud-player-' + Date.now();
                    activeMediaFrame.width = "100%";
                    activeMediaFrame.height = "166";
                    activeMediaFrame.scrolling = "no";
                    activeMediaFrame.frameborder = "no";
                    activeMediaFrame.allow = "autoplay";
                     // Add visual=true for a better default look if the embed doesn't have it
                    let scSrc = urlOrId;
                    if (!scSrc.includes('visual=')) {
                        scSrc += (scSrc.includes('?') ? '&' : '?') + 'visual=true';
                    }
                    if (!scSrc.includes('auto_play=')) {
                         scSrc += (scSrc.includes('?') ? '&' : '?') + 'auto_play=true';
                    } else {
                        scSrc = scSrc.replace(/auto_play=false/gi, 'auto_play=true'); // Ensure autoplay for API
                    }
                    activeMediaFrame.src = scSrc;


                    if (mainVideoPlayerContainer) {
                        mainVideoPlayerContainer.style.paddingBottom = "0";
                        mainVideoPlayerContainer.style.height = "166px";
                        mainVideoPlayerContainer.appendChild(activeMediaFrame);
                    }

                    soundcloudWidget = SC.Widget(activeMediaFrame);

                    soundcloudWidget.bind(SC.Widget.Events.READY, () => {
                        console.log('SoundCloud Widget Ready!');
                        soundcloudWidget.setVolume(audio.volume * 100);

                        soundcloudWidget.getDuration((duration) => {
                             if(durationElem && duration > 0) durationElem.textContent = formatTime(duration / 1000);
                        });
                        soundcloudWidget.getCurrentSound((currentSound) => {
                            if (currentSound && (songTitleElem.textContent === "Loading..." || songTitleElem.textContent === title )) { // Update title if it's generic
                                songTitleElem.textContent = currentSound.title || title;
                                // Update track in playlist if title was generic
                                if (tracks[currentTrackIndex] && tracks[currentTrackIndex].title === "SoundCloud Track"){
                                    tracks[currentTrackIndex].title = currentSound.title || title;
                                    renderAllPlaylists();
                                    saveState();
                                }
                            }
                        });

                        soundcloudWidget.bind(SC.Widget.Events.PLAY, () => {
                            if (playBtn) playBtn.style.display = 'none';
                            if (pauseBtn) pauseBtn.style.display = 'inline-block';
                        });
                        soundcloudWidget.bind(SC.Widget.Events.PAUSE, () => {
                            if (playBtn) playBtn.style.display = 'inline-block';
                            if (pauseBtn) pauseBtn.style.display = 'none';
                        });
                        soundcloudWidget.bind(SC.Widget.Events.PLAY_PROGRESS, (data) => {
                            if (!isDraggingProgress) {
                                if (currentTimeElem) currentTimeElem.textContent = formatTime(data.currentPosition / 1000);
                                soundcloudWidget.getDuration((duration) => {
                                    if (duration > 0) {
                                       if(durationElem) durationElem.textContent = formatTime(duration / 1000);
                                       if (progressBarElem) progressBarElem.style.width = (data.currentPosition / duration) * 100 + '%';
                                    }
                                });
                            }
                        });
                        soundcloudWidget.bind(SC.Widget.Events.FINISH, () => {
                            if (nextBtn) nextBtn.click();
                        });
                        soundcloudWidget.bind(SC.Widget.Events.ERROR, (err) => {
                            console.error("SoundCloud Widget Error:", err);
                            if(songTitleElem) songTitleElem.textContent = "Error loading SoundCloud track.";
                        });
                        // Attempt to play if auto_play was intended (some browsers might block it)
                        // soundcloudWidget.play(); // Already handled by auto_play=true in src
                    });

                    if (playerControlsArea) playerControlsArea.style.display = 'block';
                } else {
                    if (songTitleElem) songTitleElem.textContent = "Invalid SoundCloud Embed SRC";
                }
            } else { // Default to audio
                audio.src = urlOrId;
                audio.load();
                const trackData = tracks.find(t => t.src === urlOrId && t.type === 'audio');
                if (mainVideoPlayerContainer) {
                    mainVideoPlayerContainer.style.backgroundImage = `url('${trackData ? trackData.thumbnail : defaultThumbnail}')`;
                    mainVideoPlayerContainer.style.height = "0";
                    mainVideoPlayerContainer.style.paddingBottom = "56.25%";
                }
                if (playerControlsArea) playerControlsArea.style.display = 'block';
                // audio.play(); // Autoplay for audio if desired
                updateProgressBar();
            }
        }

        if (loadMediaBtn) {
             loadMediaBtn.addEventListener('click', () => {
                 const inputVal = mediaUrlInput.value.trim();
                 if (inputVal === "") return;
                 let type = 'unknown'; let src = inputVal; let title = "User Added Media"; let thumbnail = defaultThumbnail;
                 const youtubeID = getYouTubeVideoID(inputVal);
                 const soundcloudEmbedCodeSrc = getSoundCloudEmbedSrc(inputVal);

                 if (youtubeID) {
                     type = 'youtube';
                     src = inputVal;
                     title = `YouTube: ${youtubeID}`;
                     thumbnail = `https://img.youtube.com/vi/${youtubeID}/default.jpg`;
                 } else if (soundcloudEmbedCodeSrc) {
                     type = 'soundcloud';
                     src = soundcloudEmbedCodeSrc;
                     const titleMatch = inputVal.match(/title="([^"]*)"/); // Try to get from embed code
                     title = titleMatch && titleMatch[1] ? titleMatch[1] : "SoundCloud Track";
                     // SoundCloud thumbnail is harder to get without API call during load, use default.
                 } else if (inputVal.startsWith('http') && (inputVal.endsWith('.mp3') || inputVal.endsWith('.ogg') || inputVal.endsWith('.wav') || inputVal.includes('audio'))) { // Broader audio check
                     type = 'audio';
                     src = inputVal;
                     try {
                        const urlParts = new URL(inputVal).pathname.split('/');
                        title = decodeURIComponent(urlParts[urlParts.length -1]) || "Audio Track";
                     } catch(e) { title = "Audio Track"; }
                 }

                 if (type !== 'unknown') {
                     const newTrackData = { src, title, thumbnail, type };
                     tracks.push(newTrackData);
                     renderAllPlaylists();
                     saveState();
                     if (tracks.length === 1 && currentTrackIndex === -1) { // If it's the first track added
                        currentTrackIndex = 0;
                        loadTrackFromPlaylist(currentTrackIndex);
                     }
                 } else {
                     alert("Could not load. Please paste a valid YouTube URL, full SoundCloud Embed Code, or direct audio link (.mp3, .ogg, .wav).");
                 }
                 mediaUrlInput.value = '';
             });
        }
        if(mediaUrlInput) mediaUrlInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && loadMediaBtn) loadMediaBtn.click(); });

        function loadTrackFromPlaylist(index) {
            if (index < 0 || index >= tracks.length) {
                console.error(`Invalid track index: ${index}`);
                clearPlayerScreen();
                if (songTitleElem) songTitleElem.textContent = "Error: Track not found";
                updateProgressBar();
                return;
            }
            currentTrackIndex = index;
            const track = tracks[index];
            if (track) {
                loadMediaToPlayer(track.src, track.type, track.title);
            } else {
                console.error(`Track not found at index ${index}`);
                clearPlayerScreen();
                if (songTitleElem) songTitleElem.textContent = "Error: Track not found";
            }
            renderPlaylistView(playlistContainerDisplay, false); // To update active track highlight
            saveState();
        }

        function playCurrentMedia() {
            if (currentMediaType === 'audio') {
                audio.play().catch(error => console.error("Error playing audio:", error));
            } else if (currentMediaType === 'youtube' && activeMediaFrame && activeMediaFrame.contentWindow) {
                activeMediaFrame.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
                // YT Buttons handled by its own state if API is used, or manually here
                if (playBtn) playBtn.style.display = 'none';
                if (pauseBtn) pauseBtn.style.display = 'inline-block';
            } else if (currentMediaType === 'soundcloud' && soundcloudWidget) {
                soundcloudWidget.play();
            }
        }

        function pauseCurrentMedia() {
            if (currentMediaType === 'audio') {
                audio.pause();
            } else if (currentMediaType === 'youtube' && activeMediaFrame && activeMediaFrame.contentWindow) {
                activeMediaFrame.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
                if (playBtn) playBtn.style.display = 'inline-block';
                if (pauseBtn) pauseBtn.style.display = 'none';
            } else if (currentMediaType === 'soundcloud' && soundcloudWidget) {
                soundcloudWidget.pause();
            }
        }

        if (playBtn) playBtn.addEventListener('click', playCurrentMedia);
        if (pauseBtn) pauseBtn.addEventListener('click', pauseCurrentMedia);

        audio.addEventListener('loadedmetadata', updateProgressBar);
        audio.addEventListener('durationchange', updateProgressBar);
        audio.addEventListener('timeupdate', updateProgressBar);
        audio.addEventListener('ended', () => { if (nextBtn) nextBtn.click()});
        audio.addEventListener('play', () => {
            if (currentMediaType === 'audio') {
                if (playBtn) playBtn.style.display = 'none';
                if (pauseBtn) pauseBtn.style.display = 'inline-block';
            }
        });
        audio.addEventListener('pause', () => {
            if (currentMediaType === 'audio') {
                if (playBtn) playBtn.style.display = 'inline-block';
                if (pauseBtn) pauseBtn.style.display = 'none';
            }
        });

        function updateProgressBar() {
            if (currentMediaType === 'audio' && audio.duration && isFinite(audio.duration)) {
                const progressPercent = (audio.currentTime / audio.duration) * 100;
                if (progressBarElem) progressBarElem.style.width = progressPercent + '%';
                if (currentTimeElem) currentTimeElem.textContent = formatTime(audio.currentTime);
                if (durationElem) durationElem.textContent = formatTime(audio.duration);
            } else if (currentMediaType === 'soundcloud') {
                if (soundcloudWidget) {
                    soundcloudWidget.getDuration(duration => {
                        if(durationElem && duration > 0) durationElem.textContent = formatTime(duration / 1000);
                        else if (durationElem) durationElem.textContent = "-:--";

                        soundcloudWidget.getPosition(position => {
                            if(currentTimeElem) currentTimeElem.textContent = formatTime(position / 1000);
                            if(progressBarElem && duration > 0) progressBarElem.style.width = (position / duration) * 100 + '%';
                            else if (progressBarElem) progressBarElem.style.width = '0%';
                        });
                    });
                } else {
                    if (progressBarElem) progressBarElem.style.width = '0%';
                    if (currentTimeElem) currentTimeElem.textContent = "0:00";
                    if (durationElem) durationElem.textContent = "Loading...";
                }
            } else if (currentMediaType === 'youtube') {
                if (progressBarElem) progressBarElem.style.width = '0%';
                if (currentTimeElem) currentTimeElem.textContent = "-:--";
                if (durationElem) durationElem.textContent = "-:--";
            } else {
                if (progressBarElem) progressBarElem.style.width = '0%';
                if (currentTimeElem) currentTimeElem.textContent = "0:00";
                if (durationElem) durationElem.textContent = "0:00";
            }
        }
        function formatTime(seconds) { if (isNaN(seconds) || !isFinite(seconds) || seconds < 0) return "0:00"; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${mins}:${secs < 10 ? '0' : ''}${secs}`; }

        if (prevBtn) prevBtn.addEventListener('click', () => { if (tracks.length === 0) return; currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length; loadTrackFromPlaylist(currentTrackIndex); });
        if (nextBtn) nextBtn.addEventListener('click', () => { if (tracks.length === 0) return; currentTrackIndex = (currentTrackIndex + 1) % tracks.length; loadTrackFromPlaylist(currentTrackIndex); });

        if (progressBarContainer) progressBarContainer.addEventListener('mousedown', (e) => {
            if ((currentMediaType === 'audio' && audio.duration && isFinite(audio.duration)) ||
                (currentMediaType === 'soundcloud' && soundcloudWidget)) {
                isDraggingProgress = true;
                handleProgressBarSeek(e);
            }
        });
        window.addEventListener('mousemove', (e) => { if (isDraggingProgress) handleProgressBarSeek(e); });
        window.addEventListener('mouseup', () => { if (isDraggingProgress) isDraggingProgress = false; });

        function handleProgressBarSeek(e) {
            if (!isDraggingProgress) return;
            const rect = progressBarContainer.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const progressWidth = Math.min(Math.max(offsetX, 0), rect.width);
            const seekRatio = progressWidth / rect.width;

            if (currentMediaType === 'audio' && audio.duration && isFinite(audio.duration)) {
                audio.currentTime = seekRatio * audio.duration;
                updateProgressBar(); // Update UI immediately
            } else if (currentMediaType === 'soundcloud' && soundcloudWidget) {
                soundcloudWidget.getDuration((duration) => {
                    if (duration > 0) {
                        const seekPositionMs = seekRatio * duration;
                        soundcloudWidget.seekTo(seekPositionMs);
                        if (currentTimeElem) currentTimeElem.textContent = formatTime(seekPositionMs / 1000);
                        if (progressBarElem) progressBarElem.style.width = seekRatio * 100 + '%';
                    }
                });
            }
        }

        if (volumeSlider) volumeSlider.addEventListener('mousedown', (e) => { isDraggingVolume = true; handleVolumeSliderDrag(e); });
        window.addEventListener('mousemove', (e) => { if (isDraggingVolume) handleVolumeSliderDrag(e); });
        window.addEventListener('mouseup', () => { if (isDraggingVolume) isDraggingVolume = false; });

        function handleVolumeSliderDrag(e) {
            const rect = volumeSlider.getBoundingClientRect();
            let offsetX = e.clientX - rect.left;
            offsetX = Math.max(0, Math.min(offsetX, rect.width));
            const volumeRatio = offsetX / rect.width;

            audio.volume = volumeRatio;
            if (soundcloudWidget) soundcloudWidget.setVolume(volumeRatio * 100);
            if (volumeThumb) {
                const thumbWidth = volumeThumb.offsetWidth;
                const maxThumbLeft = rect.width - thumbWidth;
                const thumbLeft = Math.max(0, Math.min(volumeRatio * rect.width - (thumbWidth / 2), maxThumbLeft));
                 volumeThumb.style.left = `${thumbLeft}px`;
            }
            saveState(); // Save volume change
        }

        function setInitialVolume() {
            const savedVolume = (localStorage.getItem('studyHubState') && JSON.parse(localStorage.getItem('studyHubState')).volume !== undefined)
                                ? JSON.parse(localStorage.getItem('studyHubState')).volume
                                : 0.5;
            audio.volume = savedVolume;

            if (soundcloudWidget) soundcloudWidget.setVolume(savedVolume * 100);
            if (volumeSlider && volumeThumb) {
                const rect = volumeSlider.getBoundingClientRect();
                const thumbWidth = volumeThumb.offsetWidth;
                if (rect.width > 0) {
                    const maxThumbLeft = rect.width - thumbWidth;
                    const initialThumbPos = savedVolume * rect.width - (thumbWidth / 2);
                    volumeThumb.style.left = `${Math.max(0, Math.min(initialThumbPos, maxThumbLeft))}px`;
                } else {
                    volumeThumb.style.left = `calc(${savedVolume * 100}% - ${thumbWidth / 2}px)`;
                }
            }
        }

        // --- RIGHT WIDGET TAB Switching ---
        widgetTabs.forEach(tab => { tab.addEventListener('click', () => { widgetTabs.forEach(t => t.classList.remove('active')); widgetContents.forEach(c => c.style.display = 'none'); tab.classList.add('active'); const widgetName = tab.dataset.widget; const activeWidgetContent = document.getElementById(`${widgetName}-widget`); if (activeWidgetContent) activeWidgetContent.style.display = 'flex'; }); });

        // --- CHECKLIST JavaScript ---
        function addChecklistItem(taskText = null, isChecked = false, shouldSave = true) {
            const itemText = taskText || (checklistItemInput ? checklistItemInput.value.trim() : "");
            if (itemText === "" && !taskText) { alert("Please enter a task!"); return; }
            const listItem = document.createElement('li');
            const checkboxId = `task-${checklistItemIdCounter++}`;
            const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = checkboxId; checkbox.checked = isChecked;
            const label = document.createElement('label'); label.htmlFor = checkboxId; label.textContent = itemText;
            if(isChecked) { label.style.textDecoration = 'line-through'; label.style.color = '#aaa'; }
            checkbox.addEventListener('change', function() { label.style.textDecoration = this.checked ? 'line-through' : 'none'; label.style.color = this.checked ? '#aaa' : '#333'; saveState(); });
            const deleteBtn = document.createElement('button'); deleteBtn.textContent = '🗑️'; deleteBtn.className = 'delete-item-btn'; deleteBtn.title = 'Delete task';
            deleteBtn.addEventListener('click', function() { listItem.remove(); saveState(); });
            listItem.appendChild(checkbox); listItem.appendChild(label); listItem.appendChild(deleteBtn);
            if(checklist) checklist.appendChild(listItem);
            if (!taskText && checklistItemInput) checklistItemInput.value = "";
            if (shouldSave && !taskText) saveState(); // Save only if added by user, not during load
        }
        if(addChecklistItemBtn) addChecklistItemBtn.addEventListener('click', () => addChecklistItem());
        if(checklistItemInput) checklistItemInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addChecklistItem(); });

        // --- FLASHCARDS JavaScript ---
        function renderFlashcard() {
            if (!flashcardDisplay || !flashcardFront || !flashcardBack || !currentCardInfo) return;
            if (flashcards.length === 0) { flashcardFront.textContent = "No cards yet!"; flashcardBack.textContent = "Add some cards below."; flashcardDisplay.classList.remove('is-flipped'); isFlashcardFlipped = false; currentCardInfo.textContent = "0/0"; if(prevFlashcardBtn) prevFlashcardBtn.disabled = true; if(nextFlashcardBtn) nextFlashcardBtn.disabled = true; if(flipFlashcardBtn) flipFlashcardBtn.disabled = true; return; }
            if(prevFlashcardBtn) prevFlashcardBtn.disabled = currentFlashcardIndex <= 0;
            if(nextFlashcardBtn) nextFlashcardBtn.disabled = currentFlashcardIndex >= flashcards.length - 1;
            if(flipFlashcardBtn) flipFlashcardBtn.disabled = false;
            const card = flashcards[currentFlashcardIndex];
            flashcardFront.textContent = card.term;
            flashcardBack.textContent = card.definition;
            flashcardDisplay.classList.toggle('is-flipped', isFlashcardFlipped);
            currentCardInfo.textContent = `${currentFlashcardIndex + 1}/${flashcards.length}`;
        }
        function flipCurrentFlashcard() { if (flashcards.length === 0) return; isFlashcardFlipped = !isFlashcardFlipped; renderFlashcard(); }
        function renderFlashcardTermList() {
            if (!flashcardTermListUL) return; flashcardTermListUL.innerHTML = '';
            const sortedForDisplay = [...flashcards].sort((a, b) => a.term.localeCompare(b.term));
            sortedForDisplay.forEach(card => {
                const originalIndex = flashcards.findIndex(fc => fc.term === card.term && fc.definition === card.definition); // More robust find
                const listItem = document.createElement('li'); listItem.dataset.originalIndex = originalIndex;
                const termSpan = document.createElement('span'); termSpan.className = 'term'; termSpan.textContent = card.term;
                const defSpan = document.createElement('span'); defSpan.className = 'definition'; defSpan.textContent = card.definition;
                listItem.appendChild(termSpan); listItem.appendChild(defSpan);
                listItem.addEventListener('click', function() { currentFlashcardIndex = parseInt(this.dataset.originalIndex); isFlashcardFlipped = false; renderFlashcard(); saveState(); });
                flashcardTermListUL.appendChild(listItem);
            });
        }
        if(flashcardDisplay) flashcardDisplay.addEventListener('click', flipCurrentFlashcard);
        if(flipFlashcardBtn) flipFlashcardBtn.addEventListener('click', flipCurrentFlashcard);
        if(prevFlashcardBtn) { prevFlashcardBtn.addEventListener('click', () => { if (currentFlashcardIndex > 0) { currentFlashcardIndex--; isFlashcardFlipped = false; renderFlashcard(); saveState();} }); }
        if(nextFlashcardBtn) { nextFlashcardBtn.addEventListener('click', () => { if (currentFlashcardIndex < flashcards.length - 1) { currentFlashcardIndex++; isFlashcardFlipped = false; renderFlashcard(); saveState();} }); }
        if(addNewFlashcardBtn) { addNewFlashcardBtn.addEventListener('click', () => { const term = flashcardTermInput.value.trim(); const definition = flashcardDefinitionInput.value.trim(); if (term && definition) { flashcards.push({ term, definition }); flashcardTermInput.value = ''; flashcardDefinitionInput.value = ''; if (currentFlashcardIndex === -1 && flashcards.length > 0) currentFlashcardIndex = 0; else currentFlashcardIndex = flashcards.length - 1; isFlashcardFlipped = false; renderFlashcard(); renderFlashcardTermList(); saveState(); if(flashcardTermInput) flashcardTermInput.focus(); } else { alert("Please enter both a term and a definition."); } }); }
        document.addEventListener('keydown', function(e) { const flashcardsTab = document.querySelector('.widget-tab-btn[data-widget="flashcards"]'); if (flashcardsTab && flashcardsTab.classList.contains('active') && e.code === 'Space') { if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') { e.preventDefault(); flipCurrentFlashcard(); } } });

        // --- STICKY NOTES JavaScript ---
        function createStickyNote(id = `sticky-${Date.now()}`, content = '', top = 20, left = 20, z = ++stickyNoteZIndex, shouldSave = true) {
            const note = document.createElement('div'); note.classList.add('sticky-note');
            if (!stickyNotesBoard) return;

            // Ensure top/left are numbers and within bounds relative to the board scroll container
            const boardRect = stickyNotesBoard.getBoundingClientRect();
            const boardScrollWidth = stickyNotesBoard.scrollWidth;
            const boardScrollHeight = stickyNotesBoard.scrollHeight;
            const noteWidth = 180; // Assuming fixed width from CSS
            const noteHeight = 180; // Assuming fixed height

            note.style.top = `${Math.max(0, Math.min(parseFloat(top) || 20, boardScrollHeight - noteHeight))}px`;
            note.style.left = `${Math.max(0, Math.min(parseFloat(left) || 20, boardScrollWidth - noteWidth))}px`;
            note.style.zIndex = z; note.dataset.id = id;

            const header = document.createElement('div'); header.className = 'sticky-note-header';
            const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = '×'; deleteBtn.className = 'delete-sticky-btn'; deleteBtn.title = "Delete Note";
            deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); if (confirm('Delete this sticky note?')) { note.remove(); saveState(); } });
            header.appendChild(deleteBtn); note.appendChild(header);

            const textarea = document.createElement('textarea'); textarea.value = content; textarea.placeholder = "Write something...";
            textarea.addEventListener('input', () => { saveState(); });
            textarea.addEventListener('mousedown', (e) => e.stopPropagation());
            note.appendChild(textarea);

            let isDraggingNote = false; let noteStartX, noteStartY, initialMouseX, initialMouseY;
            note.addEventListener('mousedown', (e) => {
                if (e.target === deleteBtn || e.target === textarea || e.button !== 0) return;
                isDraggingNote = true; noteStartX = note.offsetLeft; noteStartY = note.offsetTop;
                initialMouseX = e.clientX; initialMouseY = e.clientY;
                note.style.zIndex = ++stickyNoteZIndex; note.style.cursor = 'grabbing';
                document.body.classList.add('is-resizing');
                document.addEventListener('mousemove', handleStickyMouseMove);
                document.addEventListener('mouseup', handleStickyMouseUp);
            });
            function handleStickyMouseMove(e) {
                if (!isDraggingNote || !stickyNotesBoard) return;
                const dx = e.clientX - initialMouseX; const dy = e.clientY - initialMouseY;
                let newLeft = Math.max(0, Math.min(noteStartX + dx, stickyNotesBoard.scrollWidth - note.offsetWidth));
                let newTop = Math.max(0, Math.min(noteStartY + dy, stickyNotesBoard.scrollHeight - note.offsetHeight));
                note.style.left = `${newLeft}px`; note.style.top = `${newTop}px`;
            }
            function handleStickyMouseUp() {
                if (!isDraggingNote) return; isDraggingNote = false;
                note.style.cursor = 'move'; document.body.classList.remove('is-resizing');
                document.removeEventListener('mousemove', handleStickyMouseMove);
                document.removeEventListener('mouseup', handleStickyMouseUp);
                saveState();
            }
            if (stickyNotesBoard) stickyNotesBoard.appendChild(note);
            if (shouldSave && id.startsWith('sticky-')) saveState(); // Save if new user-added note
        }
        if (addStickyNoteBtn) { addStickyNoteBtn.addEventListener('click', () => {
            // Add new note slightly offset from scrolled view
            const topPos = 20 + (stickyNotesBoard ? stickyNotesBoard.scrollTop : 0);
            const leftPos = 20 + (stickyNotesBoard ? stickyNotesBoard.scrollLeft : 0);
            createStickyNote(undefined, '', topPos, leftPos);
            // saveState will be called within createStickyNote if it's a new one
        });}
        if (notesArea) notesArea.addEventListener('input', saveState);

        // --- LOCAL STORAGE ---
        function saveState() {
            try {
                const state = {
                    tracks: tracks,
                    currentTrackIndex: currentTrackIndex,
                    volume: audio.volume,
                    leftColumnWidth: leftColumn.style.flexBasis || '320px',
                    checklistItems: [],
                    flashcards: flashcards,
                    currentFlashcardIndex: currentFlashcardIndex,
                    isFlashcardFlipped: isFlashcardFlipped,
                    mainNote: notesArea ? notesArea.value : '',
                    stickyNotes: []
                };

                if (checklist) {
                    checklist.querySelectorAll('li').forEach(li => {
                        const checkbox = li.querySelector('input[type="checkbox"]');
                        const label = li.querySelector('label');
                        if (checkbox && label) { // Ensure elements exist
                            state.checklistItems.push({ text: label.textContent, checked: checkbox.checked });
                        }
                    });
                }

                if (stickyNotesBoard) {
                    stickyNotesBoard.querySelectorAll('.sticky-note').forEach(note => {
                        const textarea = note.querySelector('textarea');
                        if (textarea) { // Ensure textarea exists
                             state.stickyNotes.push({
                                id: note.dataset.id, content: textarea.value,
                                top: note.offsetTop, left: note.offsetLeft,
                                zIndex: parseInt(note.style.zIndex) || 1
                            });
                        }
                    });
                }
                localStorage.setItem('studyHubState', JSON.stringify(state));
            } catch (error) {
                console.error("Error saving state to localStorage:", error);
                // Potentially alert user if storage is full or unavailable
            }
        }

        function loadState() {
            const savedStateJSON = localStorage.getItem('studyHubState');
            if (savedStateJSON) {
                try {
                    const state = JSON.parse(savedStateJSON);

                    tracks = state.tracks || [];
                    currentTrackIndex = state.currentTrackIndex !== undefined ? state.currentTrackIndex : -1;
                    audio.volume = state.volume !== undefined ? state.volume : 0.5;
                    if (state.leftColumnWidth) leftColumn.style.flexBasis = state.leftColumnWidth;

                    if (state.checklistItems && checklist) {
                        checklist.innerHTML = '';
                        state.checklistItems.forEach(item => addChecklistItem(item.text, item.checked, false));
                    }

                    flashcards = state.flashcards || [];
                    currentFlashcardIndex = state.currentFlashcardIndex !== undefined ? state.currentFlashcardIndex : -1;
                    isFlashcardFlipped = state.isFlashcardFlipped || false;


                    if (notesArea && state.mainNote !== undefined) notesArea.value = state.mainNote;

                    if (state.stickyNotes && stickyNotesBoard) {
                        stickyNotesBoard.innerHTML = '';
                        let maxZ = 0;
                        state.stickyNotes.forEach(noteData => {
                            createStickyNote(noteData.id, noteData.content, noteData.top, noteData.left, noteData.zIndex, false);
                            if (noteData.zIndex > maxZ) maxZ = noteData.zIndex;
                        });
                        stickyNoteZIndex = maxZ || 1;
                    }

                    renderAllPlaylists();
                    setInitialVolume(); // This will also use loaded volume
                    renderFlashcard();
                    renderFlashcardTermList();

                    if (tracks.length > 0 && currentTrackIndex >= 0 && currentTrackIndex < tracks.length) {
                        loadTrackFromPlaylist(currentTrackIndex);
                    } else if (tracks.length > 0) {
                        currentTrackIndex = 0;
                        loadTrackFromPlaylist(currentTrackIndex);
                    } else {
                        if(songTitleElem) songTitleElem.textContent = "Playlist Empty";
                        updateProgressBar();
                    }
                } catch (error) {
                    console.error("Error parsing saved state from localStorage:", error);
                    // Fallback to default initialization if parsing fails
                    initializePlaylist();
                    setInitialVolume();
                    updateProgressBar();
                    renderFlashcard();
                    renderFlashcardTermList();
                }
            } else {
                // No saved state, initialize with defaults
                initializePlaylist();
                setInitialVolume();
                updateProgressBar();
                renderFlashcard();
                renderFlashcardTermList();
            }
        }

        // --- INITIAL LOAD ---
        document.addEventListener('DOMContentLoaded', () => {
            const initialActivePlayerTab = document.querySelector('.player-tab-btn.active'); if(initialActivePlayerTab) { const initialPlayerTabName = initialActivePlayerTab.dataset.playerTab; let initialPlayerContentId = ''; if (initialPlayerTabName === 'player') initialPlayerContentId = 'player-content-area'; else if (initialPlayerTabName === 'load-link') initialPlayerContentId = 'link-loader-area'; const initialPlayerContent = document.getElementById(initialPlayerContentId); if(playerTabContents) playerTabContents.forEach(c => c.classList.remove('active')); if(initialPlayerContent) initialPlayerContent.classList.add('active'); }
            const initialActiveWidgetTab = document.querySelector('.widget-tab-btn.active'); if(initialActiveWidgetTab) { const initialWidgetName = initialActiveWidgetTab.dataset.widget; const initialWidgetContent = document.getElementById(`${initialWidgetName}-widget`); if(widgetContents) widgetContents.forEach(c => c.style.display = 'none'); if(initialWidgetContent) initialWidgetContent.style.display = 'flex'; }

            loadState();
            initializePlaylistEditorSortable();

            // Auto-save periodically (optional) and on unload
            // setInterval(saveState, 15000); // e.g., every 15 seconds
            window.addEventListener('beforeunload', saveState);
        });
    </script>
</body>
</html>
